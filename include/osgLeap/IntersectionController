/*
* Library osgLeap
* Copyright (C) 2013 Johannes Scholz/vtxtech. All rights reserved.
*
* This file is licensed under the GNU Lesser General Public License 3 (LGPLv3),
* but distributed WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*
*/

#ifndef OSGLEAP_INTERSECTIONCONTROLLER_
#define OSGLEAP_INTERSECTIONCONTROLLER_ 1

//-- Project --//
#include <osgLeap/Export>
#include <osgLeap/Listener>

//-- Leap --//
#include <Leap.h>

//-- OSG --//
#include <osg/Camera>
#include <osg/Object>
#include <osg/Timer>
#include <osg/Vec2>

//-- STL --//
#include <map>

namespace osgLeap {

    // A class that represents a single pointer which is calculated from a
    // finger or tool pointing at the screen
    class OSGLEAP_EXPORT Pointer: public osg::Referenced {
    public:
        Pointer(const osg::Vec2& position, int pointableID): position_(position),
            pointableID_(pointableID),
            deltaMax_(20.0f) {
            setTimedPosition(position.x(), position.y());
        }

        const osg::Vec2& getPosition() const { return position_; }
        osg::Vec2 getPosition() { return position_; }

        void setPosition(const osg::Vec2& pos) {
            if (time_ == 0 || ((pos - timedPosition_).length() > deltaMax_)) {
                setTimedPosition(pos);
            }
            position_ = pos;
        }
        void setPosition(float x, float y) { setPosition(osg::Vec2(x, y)); }

        void setTimedPosition(const osg::Vec2& pos) { timedPosition_ = pos; time_ = osg::Timer::instance()->tick(); }
        void setTimedPosition(float x, float y) {  setTimedPosition(osg::Vec2(x, y)); }
        float getDeltaMax() { return deltaMax_; }

        float clickTimeProgress(int time)
        {
            double delta = osg::Timer::instance()->delta_m(time_, osg::Timer::instance()->tick());
            if ((time_ != 0) && (delta > time)) {
                return 1.0f;
            } else {
                if (time <= 0.0f || time_ <= 0.0f) return 0.0f;
                return delta/time;
            }
        }

        bool clickTimeHasElapsed(int time)
        {
            double delta = osg::Timer::instance()->delta_m(time_, osg::Timer::instance()->tick());
            if ((time_ != 0) && (delta > time)) {
                time_ = 0;
                return true;
            }

            return false;
        }

        int getPointableID() { return pointableID_; }
        int getPointableID() const { return pointableID_; }

    private: 
        osg::Timer_t time_;
        osg::Vec2 timedPosition_;
        float deltaMax_;
        
        osg::Vec2 position_;
        int pointableID_;
    };

    typedef std::map<int, osg::ref_ptr<Pointer> > PointerMap;
    typedef std::pair<int, osg::ref_ptr<Pointer> > PointerPair;

    // A class that supports calculation of screen intersections
    class OSGLEAP_EXPORT IntersectionController: public osgLeap::Listener
    {
    public:
        // Parameter-constructor with fixed screen resolution
        // Use setResolution to update during runtime
        IntersectionController(int screenwidth = 640, int screenheight = 480);

        // Parameter-constructor with auto-update to screen resolution
        IntersectionController(osg::Camera* camera);

        // Copy constructor
        IntersectionController(const IntersectionController& lm,
            const osg::CopyOp& copyOp = osg::CopyOp::SHALLOW_COPY);

        // Virtual destructor
        virtual ~IntersectionController();

        META_Object( osgLeap, IntersectionController );
        
        // Updates the current reference resolution to calculate actual
        // pointer position from Leap Motion's relative position values
        // (Leap reports values from 0.0 to 1.0 for both axes, but we
        //  need absolute pixel coordinates here)
        //
        // NOTE: Setting resolution has no effect, if
        // IntersectionUpdateCallback was constructed with an osg::Camera
        // as reference.
        void setResolution(int screenwidth, int screenheight);

        // Called by Leap::Controller asynchronously
        virtual void onFrame(const Leap::Controller&);

        // Call this during update cycle to update PointerMap
        virtual void update();

        PointerMap getPointers() { return pointers_; }
        const PointerMap& getPointers() const { return pointers_; }

    protected:
        osg::ref_ptr<osg::Camera> camera_;
        float screenheight_;
        float screenwidth_;

        Leap::Frame frame_;
        Leap::Screen screen_;
        PointerMap pointers_;
    };

} /* namespace osgLeap */

#endif /* OSGLEAP_INTERSECTIONCONTROLLER_ */
